--DDL(CREATE, DROP, ALTER)
-- 1.TABLE 생성(제약조건)
--2.제약조건 : NOT NULL(컬럼레벨 제약만 가능!), UNIQUE, PRIMARY KEY, FOREIGEN KEY, CHECK
--2-1.제약조건 설정밥법 : 테이블레벨, 컬럼레벨
--CREATE  TABLE TABLE_NAME(
--    COLUM_NAME DATETYPE [DEFAULT EXPR][CONSTRAINT],
--    COLUM_NAME DATETYPE [DEFAULT EXPR][CONSTRAINT],
--    COLUM_NAME DATETYPE [DEFAULT EXPR][CONSTRAINT],
--    TABLE_CONSTRAINT
--)
--INSERT 구문
--INSERT INTO    TABLE_NAME[(컬럼리스트)] VALUES(VALUE, VALUE);

--CREATE
CREATE  TABLE TEST_MENBER(
    ID      VARCHAR2(50),
    PW      VARCHAR2(50) NOT NULL,
    ADDR    VARCHAR2(50) DEFAULT 'SEOUL',
    PRIMARY KEY(ID, PW) --두개의 제약조건은 테아블레벨에서만 가능
);

--INSERT
INSERT  INTO TEST_MENBER(ID, PW, ADDR) VALUES('RUBY', 'RUBY', 'SEOUL');
INSERT  INTO TEST_MENBER(ID, PW, ADDR) VALUES('RUBY', 'ADMIN', 'SEOUL');--TABLE의 제약조건으로 인해 (ID,PW)를 하나로 인식
--INSERT  INTO TEST_MENBER(ID, PW, ADDR) VALUES('ruby', null, null); --PW의 제약조건이 NOT NULL이므로 오류발생
INSERT  INTO TEST_MENBER(ID, PW) VALUES('ADMIN', 'ADMINPW'); --ADDR의 제약조건이 DEFAULT SEOUL이므로 ADDR의 빈 곳에 자동으로 입력

--SELECT
SELECT  *
FROM    TEST_MENBER;

--DROP
DROP    TABLE TEST_MENBER;

--FK : 부모에 의존하는 데이터이거나 NULL값을 허용
--부모를 참조하는 외래키 만들기(컬럼레벨)
CREATE TABLE TABLE_FK(
    ID      CHAR(3) PRIMARY KEY,
    NAME    VARCHAR(50) NOT NULL,
    LID     CHAR(2) REFERENCES LOCATION(LOCATION_ID),
    
);

--부모를 참조하는 외래키 만들기(테이블레벨)
CREATE TABLE TABLE_FK(
    ID      CHAR(3) PRIMARY KEY,
    NAME    VARCHAR(50) NOT NULL,
    LID     CHAR(2),
    FOREIGN KEY(LID) REFERENCES LOCATION (LOCATION_ID)
);

INSERT INTO TABLE_FK VALUES('A', 'RUBY', 'A1');
INSERT INTO TABLE_FK VALUES('B', 'DIA', 'OT');
INSERT INTO TABLE_FK VALUES('C', 'DIA', NULL);
--INSERT INTO TABLE_FK VALUES('A', 'RUBY', 'X') --부모키에 X가 없으므로 오류

SELECT  *
FROM    TABLE_FK;

DROP TABLE TABLE_FK;

--만들어진 테이블에 JOIN
SELECT  LOC_DESCRIBE, ID
FROM    LOCATION L
JOIN    TEST_FK T ON(L.LOCATION_ID = T.LID);

SELECT  *
FROM    LOCATION;

--한개의 부모테이블을 갖는 자식테이블
CREATE TABLE    TEST_COMPOSIT_PK(
    ID      VARCHAR2(50),
    NAME    VARCHAR2(50),
    SALARY  NUMBER  CHECK(SALARY > 0),
    GENDER  CHAR(1) CHECK(GENDER IN('M', 'F')),
    PRIMARY KEY(ID, NAME)
);

--INSERT INTO TEST_COMPOSIT_PK VALUES('RUBY', '녕', -100, 'F'); --CHECK제약조건에 SALARY > 0 이므로 오류
INSERT INTO TEST_COMPOSIT_PK VALUES('RUBY', '녕', 100, 'F');

SELECT  *
FROM    TEST_COMPOSIT_PK;

DROP TABLE  TEST_COMPOSIT_PK;

-----------------------------------------------------------------
CREATE TABLE    TEST_COMPOSIT_FK(
    PID     VARCHAR2(50),
    ID      VARCHAR2(50),
    NAME    VARCHAR2(50),
    FOREIGN KEY (ID, NAME) REFERENCES TEST_COMPOSIT_PK (ID, NAME),
    PRIMARY KEY (PID, ID, NAME)
);

INSERT INTO TEST_COMPOSIT_FK VALUES ('P001', 'RUBY', '녕');

SELECT  *
FROM    TEST_COMPOSIT_FK ;

DROP TABLE TEST_COMPOSIT_FK;

--두개의 부모테이블을 갖는 자식테이블
CREATE TABLE    TEST_S1(
    SID     VARCHAR(50) PRIMARY KEY,
    PHONE   NUMBER
);

INSERT INTO TEST_S1 VALUES('RUBY', 12341234);
INSERT INTO TEST_S1 VALUES('DIA', 11112222);

SELECT  *
FROM    TEST_S1;

DROP TABLE  TEST_S1;
 ------------------------------------------------------------
CREATE TABLE    TEST_S2(
    TID     VARCHAR(50) PRIMARY KEY,
    NAME    VARCHAR(50) DEFAULT 'DEFAULT'
);

INSERT INTO TEST_S2 VALUES ('FRUIT', 'CHERRY');
INSERT INTO TEST_S2 VALUES ('ANIMAL', 'RABBIT');

SELECT *
FROM    TEST_S2;

DROP TABLE TEST_S2;
--------------------------------------------------------------
CREATE TABLE    TEST_CHILD(
    CID     VARCHAR(50) PRIMARY KEY,
    SID     VARCHAR(50) REFERENCES TEST_S1(SID),
    TID     VARCHAR(50) REFERENCES TEST_S2(TID)
);

INSERT INTO TEST_CHILD VALUES ('녕', 'RUBY', 'FRUIT');
INSERT INTO TEST_CHILD VALUES ('은영', 'DIA', 'ANIMAL');

SELECT  *
FROM    TEST_CHILD;

DROP TABLE TEST_CHILD;

--VIEW : 복잡한 쿼리구문을 단순하게 만들 수 있음
--CREATE OR REPLACE VIEW_NAME(컬럼의 별칭)
--AS SUBQUERY;
CREATE OR REPLACE VIEW V_EMP(NAME, DEPT)
AS SELECT   EMP_NAME, DEPT_ID
    FROM    EMPLOYEE
    WHERE   DEPT_ID='90';

SELECT  *
FROM    V_EMP;

--직급이 사원인 직원의 이름, 부서이름, 직급을 갖는 V_EMP_DEPT_JOB 뷰를 작성
CREATE OR REPLACE VIEW V_EMP_DEPT_JOB("이름", "부서이름", "직급")
AS SELECT   EMP_NAME, DEPT_NAME, JOB_TITLE
    FROM    EMPLOYEE
    JOIN    JOB         USING(JOB_ID)
    JOIN    DEPARTMENT  USING(DEPT_ID)
    WHERE   DEPT_NAME = '사원';

SELECT  *
FROM    V_EMP_DEPT_JOB;

DROP VIEW V_EMP_DEPT_JOB;

--SEQUENCE 객체
--CREATE SEQUENCE SEQUENCE_NAME;
--NEXTVAL, CURRVAL
CREATE SEQUENCE TEST_SEQ
START WITH      300
INCREMENT BY    2
MAXVALUE        310
NOCYCLE
NOCACHE;

SELECT  TEST_SEQ.NEXTVAL    FROM DUAL;
SELECT  TEST_SEQ.CURRVAL    FROM DUAL;

DROP SEQUENCE TEST_SEQ;

--TOP-N 분석 : 조건에 맞는 최상위 레코드 N개를 식별하는 쿼리기법
--원리 : 정렬, ROWNUM, 부여된 순번대로 필요한만큼 가져옴

--부서별 평균급여보다 많은 급여를 받는 사원의 이름, 급여조회
--FROM절에 서브쿼리를 이용해서 작성 --> INLINE VIEW
--평균급여는 정수3자리에서 올림
SELECT  ROWNUM, EMP_NAME, SALARY
FROM    (   SELECT     DEPT_ID, ROUND(AVG(SALARY), -3) AS DAVG
            FROM       EMPLOYEE
            GROUP BY   DEPT_ID  ) INVIEW
JOIN    EMPLOYEE E ON(E.DEPT_ID = INVIEW.DEPT_ID)
WHERE   SALARY > INVIEW.DAVG 
AND     ROWNUM=1 ; --ROWNUM : 최상위 첫번째만 출력가능
--ORDER BY 3 DESC ;--ROWNUM의 번호가 섞여버림

SELECT  ROWNUM, EMP_NAME, SALARY
FROM    (SELECT EMP_NAME, SALARY
         FROM    (   SELECT     DEPT_ID, ROUND(AVG(SALARY), -3) AS DAVG
                     FROM       EMPLOYEE
                     GROUP BY   DEPT_ID  ) INVIEW
        JOIN    EMPLOYEE E ON(E.DEPT_ID = INVIEW.DEPT_ID)
        WHERE   SALARY > INVIEW.DAVG 
        ORDER BY 2 DESC)
WHERE   ROWNUM = 1;

--RANK(), WITHIN, OVER
SELECT  *
FROM    (SELECT EMP_NAME, 
                SALARY, 
                RANK() OVER(ORDER BY SALARY DESC)() AS R
         FROM   EMPLOYEE)
WHERE R <= 5;

--DML(INSERT, UPDATE, DELETE)
--UPDATE 구문 : 수정
UPDATE  TABLE_NAME
SET     [COLUM_NAME = VALUE, ]
WHERE   CONDITION;

--DELETE 구문
DELETE  FROM TABLE_NAME
WHERE   CONDITION;

CREATE TABLE    TEST_DML(
    ID  VARCHAR2(50) PRIMARY KEY,
    PW  VARCHAR2(50) NOT NULL,
    NAME VARCHAR2(50) NOT NULL,
    SALARY  NUMBER  CHECK(SALARY > 0),
    MARRIGE CHAR(1) CHECK(MARRIGE IN ('Y', 'N'))
)

INSERT INTO TEST_DML VALUES('RUBY', 'RUBY', '녕', 100, 'N');
INSERT INTO TEST_DML VALUES('DIA', 'DIA', '은영', 100, 'N');

UPDATE  TEST_DML
SET     MARRIGE='Y'
WHERE   ID='RUBY';

SELECT  *
FROM    TEST_DML;

DELETE  FROM TEST_DML
WHERE   ID='DIA';
